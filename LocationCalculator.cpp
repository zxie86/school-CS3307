/**
 * @author Malcolm Shelley
 * @date December 2, 2020
 * @brief Calculates the location of a beacon using the signal strength of three receivers
 */
#include <cmath>
#include "LocationCalculator.h"

/**
* @brief Constructor initializes 3 receiver objects for trilateration, and room dimenstions
* @param r1 first receiver object
* @param r2 second receiver object
* @param r3 third receiver object
* @param newWidth width of the room
* @param newHeight height of the room
*
*/
LocationCalculator::LocationCalculator(Receiver r1, Receiver r2, Receiver r3, int newWidth, int newHeight){
    width = newWidth;
    height = newHeight;
    // max distance is root(x^2 + y^2) with 10% possible error
    maxDistance = sqrt(pow(width + width/10, 2) + pow(height + height/10, 2));
    receiver1 = r1;
    receiver2 = r2;
    receiver3 = r3;
}

/**
 * @brief finds the intersection points between the two circles generated by r1 and r2
 * @param r1 receiver 1
 * @param r2 receiver 2
 * @param r3 receiver 3
 * @return if a point lies inside r3, returns that point otherwise returns (-1,-1)
 */
Location LocationCalculator::findIntersection(Receiver r1, Receiver r2, Receiver r3) {
    double dis1 = r1.getSignal() * maxDistance;
    double dis2 = r2.getSignal() * maxDistance;
    double dis3 = r3.getSignal() * maxDistance;
    Location loc1 = r1.getLocation();
    Location loc2 = r2.getLocation();
    Location loc3 = r3.getLocation();

    double a, dx, dy, d, h, rx, ry;
    double point2_x, point2_y;

    /*
     *  dx and dy are the vertical and horizontal distances between the circle centers.
     */
    dx = loc2.getX() - loc1.getX();
    dy = loc2.getY() - loc1.getY();

    /*
     * Determine the straight-line distance between the centers.
     */
    d = sqrt((dy*dy) + (dx*dx));

    /*
     * Check for solvability.
     */
    if (d > (dis1 + dis2))
    {
        /*
         * no solution. circles do not intersect.
         */
        return Location(-1, -1);
    }

    /*
     * 'point 2' is the point where the line through the circle
     * intersection points crosses the line between the circle centers.
     */

    /*
     * Determine the distance from point 0 to point 2.
     */
    a = ((dis1*dis1) - (dis2*dis2) + (d*d)) / (2.0 * d) ;

    /*
     * Determine the coordinates of point 2.
     */
    point2_x = loc1.getX() + (dx * a/d);
    point2_y = loc1.getY() + (dy * a/d);

    /*
     * Determine the distance from point 2 to either of the intersection points.
     */
    h = sqrt((dis1*dis1) - (a*a));

    /*
     * Now determine the offsets of the intersection points from point 2.
     */
    rx = -dy * (h/d);
    ry = dx * (h/d);

    /*
     * Determine the absolute intersection points.
     */
    double intersectionPoint1_x = point2_x + rx;
    double intersectionPoint2_x = point2_x - rx;
    double intersectionPoint1_y = point2_y + ry;
    double intersectionPoint2_y = point2_y - ry;

    /*
     * determine distance from circle 3 to each of the points.
     */
    dx = intersectionPoint1_x - loc3.getX();
    dy = intersectionPoint1_y - loc3.getY();
    double d1 = sqrt((dy*dy) + (dx*dx));

    dx = intersectionPoint2_x - loc3.getX();
    dy = intersectionPoint2_y - loc3.getY();
    double d2 = sqrt((dy*dy) + (dx*dx));

    /*
     * returns the point that lies inside circle3, if neither do, returns (-1,-1)
     */
    if (d1 < dis3){
        return Location((int)intersectionPoint1_x, (int)intersectionPoint1_y);
    }
    else if (d2 < dis3){
        return Location((int)intersectionPoint2_x, (int)intersectionPoint2_y);
    }
    else{
        return Location(-1,-1);
    }
}
/**
 * @brief Calculates the location of the beacon within the three receivers
 * Uses trilateration to get the intersection point of the three circles generated by the
 * receiver distances to the beacon.
 * @return Intersection point Location (int, int) or Location (-1, -1) when invalid.
 */
Location LocationCalculator::calculateLocation() {
    double dis1 = (1 - receiver1.getSignal()) * maxDistance;
    double dis2 = (1 - receiver2.getSignal()) * maxDistance;
    double dis3 = (1 - receiver3.getSignal()) * maxDistance;
    Location loc1 = receiver1.getLocation();
    Location loc2 = receiver2.getLocation();
    Location loc3 = receiver3.getLocation();

    double a, dx, dy, d, h, rx, ry;
    double point2_x, point2_y;
    Location innerPoints[3];

    /*
     * dx and dy are the vertical and horizontal distances between the circle centers.
     */
    dx = loc2.getX() - loc1.getX();
    dy = loc2.getY() - loc1.getY();

    /*
     * Determine the straight-line distance between the centers.
     */
    d = sqrt((dy*dy) + (dx*dx));

    /*
     * Check for solvability.
     */
    if (d > (dis1 + dis2))
    {
        /*
         * no solution. circles do not intersect.
         */
        return Location(-1, -1);
    }

    /*
     * 'point 2' is the point where the line through the circle
     * intersection points crosses the line between the circle centers.
     */

    /*
     * Determine the distance from point 0 to point 2.
     */
    a = ((dis1*dis1) - (dis2*dis2) + (d*d)) / (2.0 * d) ;

    /*
     * Determine the coordinates of point 2.
     */
    point2_x = loc1.getX() + (dx * a/d);
    point2_y = loc1.getY() + (dy * a/d);

    /*
     * Determine the distance from point 2 to either of the intersection points.
     */
    h = sqrt((dis1*dis1) - (a*a));

    /*
     * Now determine the offsets of the intersection points from point 2.
     */
    rx = -dy * (h/d);
    ry = dx * (h/d);

    /*
     * Determine the absolute intersection points.
     */
    double intersectionPoint1_x = point2_x + rx;
    double intersectionPoint2_x = point2_x - rx;
    double intersectionPoint1_y = point2_y + ry;
    double intersectionPoint2_y = point2_y - ry;


    /*
     * determine if circle 3 intersects at either of the above intersection points.
     */
    dx = intersectionPoint1_x - loc3.getX();
    dy = intersectionPoint1_y - loc3.getY();
    double d1 = sqrt((dy*dy) + (dx*dx));

    dx = intersectionPoint2_x - loc3.getX();
    dy = intersectionPoint2_y - loc3.getY();
    double d2 = sqrt((dy*dy) + (dx*dx));

    /*
     * if the distance from an intersection point to centre of the third circle is the same as the radius of the
     * third circle, it intersects with that point
     */
    if(std::abs(d1 - dis3) < 0.01) {
        return Location((int)intersectionPoint1_x, (int)intersectionPoint1_y);
    }
    else if(std::abs(d2 - dis3) < 0.01) {
        return Location((int)intersectionPoint2_x, (int)intersectionPoint2_y);
    }
    /*
     * if all three do not intersect in one point, finds the three innermost intersection points and returns their
     * midpoint as the location of the beacon
     */
    else if (d1 < dis3){
        innerPoints[0] = Location((int)intersectionPoint1_x, (int)intersectionPoint1_y);
    }
    else if (d2 < dis3){
        innerPoints[0] = Location((int)intersectionPoint2_x, (int)intersectionPoint2_y);
    }
    else{
        return Location(-1,-1);
    }

    /*
     * knowing the three circles don't intersect, finds the other two points of the inner triangle
     * if one of the circles lies outside of the other two circles intersection points, returns (-1,-1)
     */
    innerPoints[1] = findIntersection(receiver1, receiver3, receiver2);
    if(innerPoints[1].getX() == -1){
        return innerPoints[1];
    }
    innerPoints[2] = findIntersection(receiver2, receiver3, receiver1);
    if(innerPoints[2].getX() == -1){
        return innerPoints[2];
    }
    /*
     * find midpoint of two sides of the triangle
     */
    double mid1x = (innerPoints[0].getX() + innerPoints[1].getX()) / 2;
    double mid1y = (innerPoints[0].getY() + innerPoints[1].getY()) / 2;
    double mid2x = (innerPoints[0].getX() + innerPoints[2].getX()) / 2;
    double mid2y = (innerPoints[0].getY() + innerPoints[2].getY()) / 2;

    // Line represented as a1x + b1y = c1
    double a1 = innerPoints[2].getY() - mid1y;
    double b1 = mid1x - innerPoints[2].getX();
    double c1 = a1*(mid1x) + b1*(mid1y);
    // Line represented as a2x + b2y = c2
    double a2 = innerPoints[1].getY() - mid2y;
    double b2 = mid2x - innerPoints[1].getX();
    double c2 = a2*(mid2x)+ b2*(mid2y);
    double determinant = a1*b2 - a2*b1;

     //if lines are parallel
    if (determinant == 0) {
        return Location(-1,-1);
    } else {
        double x = (b2*c1 - b1*c2)/determinant;
        double y = (a1*c2 - a2*c1)/determinant;
        return Location((int)x,(int)y);
    }
}

/**
* @brief default destrcutor
*/
LocationCalculator::~LocationCalculator(){

}
